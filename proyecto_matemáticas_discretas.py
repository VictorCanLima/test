# -*- coding: utf-8 -*-
"""Proyecto Matemáticas Discretas

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oyi9OcbDlrzGsYVjUJO3xlv5Jb0pg44b

#**Algoritmos Elementales con Grafos**
##Reporte práctico experimental - Unidad 5


En este trabajo se muestra la programación y el análisis de 5 algoritmos relaionados a la unidad 5, estos son la representación de grafos, la búsqueda en anchura, la búsqueda en profundidad, el algoritmo de Kruskal y el algoritmo de Prim.

###**Creación y construcción de grafos**
####Planteamiento del problema
El problema a resolver para la creación de grafos es conseguir una abstracción útil de un grafo cualquiera, este puede ser dirigido, no dirigido, con pesos en las aristas o sin ellos. Esta abstracción debe facilitar la aplicación de otros algoritmos para obtener información, como son la búsqued aen anchura, la búsqueda en profundidad o la obtención de un árbol recubridor mínimo. 
####Solución propuesta
La solución propuesta es la creación de un conjunto de clases que de cierta manera imite a una lista de adjacencias, con algunas alteraciones en su estructura, para facilitar la manipulación del grafo al momento de aplicarsele algun otro algoritmo como los mencionados anteriormente.
####Definición del problema
Para poder llevar a cabo la solución propuesta, es necesario crear dos clases, la clase *Graph*, cuya instancia se encargará de representar la estructura general de un grafo, y la clase *Node*, cuyas instancias representarán a los vertices y serán organizadas e instanseadas por un objeto de la clase Grafo.
En la figura anterior es posible observar el diagrama de clase que ilustra la forma en que la clase *Graph* y la clase *Node* formaran la estructura completa de un grafo. La clase *Node* carece de métodos, se compone del atributo *name*, que será el id del nodo, es el argumento de entrada necesario para hacer una instancia de la clase; el atributo *links* guardará una lista de todos los vertices adyacentes; el atributo *state* servirá durante la aplicación de algunos algoritmos sobre el grafo; por otro lado los atributos *tier* y *time_stamps* son atributos necesarios para los algoritmos de búsqueda en anchura y búsqueda en profundidad, respectivamene. ![](https://drive.google.com/uc?id=1Fjt2BCJYvS58sp67cDi42dOgcCkSoAgo)
Del otro lado tenemos a la clase *Graph*, en ésta, el atributo *adj_list* contiene a todos los vertices que constituyen al grafo, estos serán instancias de *Node*; para obtener tal lista se utiliza el método *create_AdjList*, que utiliza los atributos *V* y *E* para crear los nodos y organizarlos; *V* y *E* reciben a los argumenos de entrada para inicializar un Grafo, el primer atributo recibe una lista con los nombres de odos los nodos, el segundo recibe una lista de listas, cada sub lista debe contener 3 elementos, el primero es un nodo N, el segundo es el nodo M al que apunta N, el tercero es el peso de esa arista. En caso de inicializar un grafo sin tales argumentos de entrada, el grafo iniciará vacío, sin vertices. Los métodos *Add_v* y *Add_e* permiten añadir a *V* y a *E* elementos. El método *create_AdjList* debe ser llamado siempre que se actualice *V* y *E*. Por último el atributo time es utilizado durante la aplicación del algoritmo de búsqueda en profundidad. El atributo *root* es útil en caso de que el grafo sea un árbol, éste apuntará al nodo de *adj_list* que éste definido como el comienzo o la raíz del árbol. Por último, el método *print_AdjList* permite mostrar la lista de adjacencias del grafo creado.\\
La idea con esta forma de representar un grafo es poder navegar a través del mismo utilizando el atributo *adj_list*, que permite acceder a cualquiera de los vertices, o *root* en caso de trabajar con árboles. Este concepto permite representar todo tipo de grafos, dirigidos, no dirigidos, árboles y grafos ponderados. A continuación se muestra el pseudocódigo de la clase Graph y la clase Node.

\\

```
class Node
  constructor(who)
    name is who
    links is []
    state is NULL
    tier is 0
    time_stamps is [0,0]
class Graph
  constructor(vert is [],edg is [])
    adj_list is []
    V is vert
    E is edg 
    root is None
    time is 0
  create_AdjList()   //create adjacency list based on V and E
    if V is not empty
      for each id from V
        create new Node(id) node
        add node to adj_list
      for each e from E
        for each v from adj_list
          if first id of e is name of v
            for each u from adj_list
              if second id of e is name of u
                add [u, weight in e] to links
  Add_v(v)          //add new vertex to V
    if V is not empty 
      for each u from V
        if u is v
          repeated
    if not repeated
        add v to V
  Add_e(e)           //Add new edge to E, between 2 vertex in V 
    if E is not empty
      for each c from E
        if c is e
          repeated
    if not repeated
        add e to E
  print_AdjList()    //Show adjacency list      
    if adj_list is not empty
      for each p in 0 to length of adj_list
        show name of adj_list[p]
        for each l from links of adj_list[p]
          show l
```
Con respcecto al tiempo de ejecución, hay uno distinto para cada método. El tiempo de ejecución para el método *create_AdList* tiene un tiempo de ejecución de $O(|V|\cdot|E|)$, debido a que por cada arista en *E* es necesario revisar la combinación de vertices que la compone, en el peor de los casos todos los vertices estarán conectados con todos, incluyendose a sí mismos, volviendose entonces equivalente a $O(|V|^4)$, pues en *E*, la conexión de todos los nodos con todos, supondría un total de $|V|^2$ elementos, para la comparación de cada conjunto de coordenadas *e*, se utilizan dos ciclos anidados que  recorren todos los vertices, es decir $|V|^2$ comparaciones. Para *Add_v*, su tiempo de ejecución es de $O(|V|)$, solo para revisar que no se añadan vertices repetidos, analogamente sucede lo mismo con *Add_e*, con un tiempo de ejecución de $O(|E|)$ el cual es igual a $O(|V|^2)$ si todos los vertices están conectados con todos, por lo que se explicó anteriormente. Por último para *print_AdjList* el peor tiempo de ejecución posible es $O(|V|^2)$, en el caso de que cada vertice sea adyacente a todos los vertices dentro del grafo, inclusive sí mismo. \\
A continuación aparece el código escrito en Python 3, seguido de éste se encuentra un conjunto de listas de vertices y aristas, así como instrucciones para crear 3 grafos a partir de tales conjuntos.

\\

\\

\\

\\

###Graph creation
"""

class Node:
  def __init__(self,who): #Inicialización de un objeto nodo
    self.name = who
    self.data = None
    self.links = []
    self.state = None
    self.tier = 0
    self.time_stamps = [0,0]

class Graph: 
  def __init__(self,vert=[],edg=[]):#Inicialización de un objeto Grafo
    self.adj_list = []
    self.V = vert
    self.E = edg 
    self.root = None
    self.time = 0
  def create_AdjList(self): #Creación de lista de adyacencia a partir de sus listas de vertices y aristas, si existen elementos en estas listas
    if self.V:
      for i in self.V:
        node = Node(i)
        print("Nuevo nodo con id ",i)
        self.adj_list.append(node)
      for i in self.E:
        for j in self.adj_list:
          if i[0] is j.name:
            for k in self.adj_list:
              if i[1] is k.name:
                print("Nodo ",j.name," apunta a ",k.name)
                j.links.append([k,i[2]])
  def Add_v(self,v): #Agregación de un elemento a V
    check = True
    if self.V:
      for i in self.V:
        if i == v:
          check = False
    if check:
        self.V.append(v)
  def Add_e(self,e): #Agregación de un elemento a E
    check = True
    if self.E:
      for i in self.E:
        if i == e:
          check = False
    if check:
        self.E.append(e)
  def print_AdjList(self): #Función para mostrar la lista de adyacencia si esta ya fue generada
    if self.adj_list:
      for n in range(0,len(self.adj_list)):
        print(self.adj_list[n].name)
        for i in self.adj_list[n].links:
          print("-->",i[0].name)

vertex1 = ['A','B','C','D','E','F','G','H']
edges1 = [['A','B',-1],['A','E',-1],['B','A',-1],['B','F',-1],['C','F',-1],['C','G',-1],['C','D',-1],['D','C',-1],['D','G',-1],['D','H',-1],
          ['E','A',-1],['F','B',-1],['F','C',-1],['F','G',-1],['G','F',-1],['G','C',-1],['G','H',-1],['G','D',-1],['H','G',-1],['H','D',-1]]
         
vertex2 = ['A','B','C','D','E','F']
edges2 = [['A','B',1],['A','D',1],['B','E',1],['C','E',1],['C','F',1],['D','B',1],['E','D',1],['F','F',1]]

vertex3 = ['A','B','C','D','E','F','G','H','I']
edges3 = [['A','B',4],['A','H',8],['B','A',4],['B','H',11],['B','C',8],['C','B',8],['C','D',7],['C','I',2],['C','F',4],['D','C',7],
          ['D','E',9],['D','F',14],['E','D',9],['E','F',10],['F','C',4],['F','D',14],['F','E',10],['F','G',2],['G','F',2],['G','I',6],
          ['G','H',1],['H','G',1],['H','I',7],['H','B',11],['H','A',8],['I','C',2],['I','G',6],['I','H',7]]

graph1 = Graph(vertex1,edges1)
graph1.create_AdjList()
print("\n")
graph1.print_AdjList()
print("\n")
print("\n")
graph2 = Graph(vertex2,edges2)
graph2.create_AdjList()
print("\n")
graph2.print_AdjList()
print("\n")
print("\n")
graph3 = Graph(vertex3,edges3)
graph3.create_AdjList()
print("\n")
graph3.print_AdjList()

"""###**Búsqueda en anchura**
####Planteamiento del problema
El objetivo o la problemática con respecto a la búsqueda en anchura, es programar un algoritmo que atraviese un grafo comenzando desde cualquier vertice perteneciente al mismo que haya sido seleccionado, atravesando el grafo por niveles o capas, hasta llegar a los nodos más alejados con respecto al vertice de referencia.
####Solución propuesta
La solución propuesta para el algoritmo de búsqueda en anchura es una función que, a partir de un grafo y un vertice del mismo, genere un nuevo grafo, un árbol, cuyas ramificaciones representen las capas del grafo original.
####Definición del problema
Para poder llevar a la realidad la solución propuesta, es necesario plantear un algorimo que aproveche las estructuras *Graph* y *Node* no solo para crear el arbol de búsqueda en anchura sino también para recorrer el grafo original. Abajo se muestra el pseudocósigo de la implemenación de la propuesta de solución, el algoritmo recibe como argumentos de entrada al grafo del cuál se obtendrá su árbol de búsqueda en anchura, y el nodo a partir del cuál se comenzará tal búsqueda. \\
El algoritmo inmediatamente crea una instancia de la clase Graph, sin argumentos de entrada, después, con el método *Add_v* se añadirá al atributo *V* del nuevo árbol, el nombre de todos los vertices del grafo original. A continuación, el estado de todos los vertices del grafo original se establecen como desconocidos excepto el original, que se establecerá como descubierto. Gracias al atributo links de cada vertice, que guarda los nodos adyacentes, primero se revisa cada nodo adyacente a la raíz, la cual será el primer nodo a analizar, y se guardan en una cola para ser analizados después, cada nodo adyacente al nodo analizado será marcado como descubierto, y una vez que un nodo pase a ser analizado, su estado cambiará a conocido. \\
La raíz sera el nivel cero del árbol, todos los nodos adyacentes a la raíz serán el nivel 1, los adyacentes a los adyacentes serán el nivel 2 y así consecutivamente. Cada que un nodo es descubierto, se guarda el nivel al que pertenece en una lista, y al atributo *E* del árbol de búsqueda se le añade la arista por el cual el nodo ha sido descubierto, por medio del método *Add_e*.\\
Una vez todos los nodos han sido analizados, ya se tienen todas las aristas del árbol de búsqueda y también el nivel al que pertenecen todos los nodos. De tal forma que ya es posible crear la lista de adyacencia con el método *create_AdjList*, y asignar a cada nodo del atributo *adj_list* del árbol de búsqueda el nivel al que pertenece, es decir, asignar al atributo *tier* de cada nodo, el valor que le corresponde.

```
BFS(G,s)
  new Graph() bfs_tree    // Creates new empty tree
  for each u in adj_list of G //Initializes all atributes needed
    add u to V of bfs_tree
    if u is not s
      state of u is "unknown"
      tier of u is 0
  state of s is "discovered"
  tier of s is 0
  tiers is [ ] 
  queue is [ ] 
  push s into queue
  while queue is not empty //Analyzes each vertex of the original Graph
    pop w from queue 
    for each v adjacent to w  //Checks every vertex adjacent to the current vertex that is being analyzed
      if state of v is "unknown" //If it was a non checked at all vertex, it is added as a new edge and tier for it is set
        state of v is "discovered"
        tier of v is tier of w +1
        add tier of v to tiers
        add [w name, v name, weight between w and v] to E of bfs_tree
        push v into queue
    state of w is "known"
  create adj_list of bfs_tree //Creates Adjacency List of the tree once analysis is finished
  for each r in adj_list of bfs_tree // Sets the root of the new tree
    for each e in tiers_list
      if name of r is name in e
        tier of r is tier in e
    if name of r is name of s
      root of bfs_tree is r
  return bfs_tree
```

\\

\\

El tiempo de ejecución de éste algoritmo es de $O(|V|^2)$, ya que, en el peor de los casos, cada vertice analizado para generar el árbol, sera adyacente a todos los demás vertices, inclusive a sí mismo. A continuación se muestra el código escrito en Python 3, para implementar éste algoritmo. Seguido de éste, se propone un código de muestra para obtener un árbol de búsqueda en anchura a partir del grafo *graph1*, creado en la sección anterior.

###Breadth First Search
"""

def BFS(G,s):
  bfs_tree = Graph()
  bfs_tree.E = []
  bfs_tree.V = []
  tiers_list = []
  for u in G.adj_list: #El estado de los nodos del grafo original se inicializa
    bfs_tree.Add_v(u.name)
    if u is not s:
      u.state = "unknown"
      u.tier = 0
  s.state = "discovered"
  s.tier = 0
  adjs_queue = []
  adjs_queue.insert(0,s)
  while adjs_queue: #Se analizan todos los nodos del grafo original
    w = adjs_queue.pop()
    print("Analizando nodo ",w.name)
    for v in w.links: #De cada nodo analizado se revisan los nodos que son adyacentes a él, dandoles a estos una capa o nivel
      if v[0].state == "unknown":
        v[0].state = "discovered"
        v[0].tier = w.tier+1
        tiers_list.append([v[0].name,v[0].tier])
        bfs_tree.Add_e([w.name,v[0].name,v[1]])
        bfs_tree.Add_e([v[0].name,w.name,v[1]])
        adjs_queue.insert(0,v[0])
        print("Nodo ",v[0].name," descubierto")
    w.state = "known"
    print("Nodo ",w.name," terminado")
  bfs_tree.create_AdjList()
  for r in bfs_tree.adj_list: #Al nuevo árbol se le asigna su raíz como el nodo del cual partió el análisis
    for e in tiers_list:
      if r.name == e[0]:
        r.tier = e[1]
    if r.name == s.name:
      bfs_tree.root = r
  return bfs_tree

bfs_of_graph = BFS(graph1,graph1.adj_list[1])
print("\n\n")
print("Raíz del árbol BFS: ",bfs_of_graph.root.name,"\n\n")
bfs_of_graph.print_AdjList()

"""###**Búsqueda en profundidad**
####Planteamiento del problema
El objetivo o la problemática con respecto a la búsqueda en profundidad, es programar un algoritmo capaz de atravesar un grafo comenzando desde un vertice elegido como raíz, atravesando el grafo desde la raíz hasta el nodo más alejado posible, y así con cada camino posible hasta haber pasado por cada vertice. Generando un conjunto de marcas para indicar el paso en que cada grafo es atravesado.
####Solución propuesta
La solución propuesta para el algoritmo de búsqueda en profundidad es una función, llamada *DFS* que estalezca las marcas resultantes de la búsqueda, tales marcas serían los valores del atributo *time_stamps* de cadanodo perteneciente al grafo.
####Definición del problema
Para poder llevar a la realidad la solución propuesta, es necesario plantear un algorimo que aproveche las estructuras *Graph* y *Node* para hacer la búsqueda y poder definir los valores de *time_stamps*. Se utiliza el atributo *time* del grafo como punto de referencia para la búsqueda.\\
El algoritmo explora a partir de cada nodo descubierto hasta el último nodo desconocido alcanzable a partir de éste, con ayuda de el atributo *links* de cada vertice. Asignando la primera marca en el momeno en que el nodo es descubierto y la segunda una vez que se ha terminado de explorar desde tal nodo. La exploración se realiza a través de la recursión de una función anidada a la función principal, llamada *DFS_From*.
```
DFS(G)
  time is 0  // time of the graph is set to zero
  for each u in adj_list of G // Initializes all attributes needed
    state of u is "unknown"
    time_stamps of u are [0,0]
  for each u in adj_list of G  // Checks every vertex of the graph
    if state of u is "unknown"
      DFS_From(u) 
  for each v in  adj_list of G
    print(v.name," timestamps: ",v.time_stamps)
  DFS_From(s) // Subfunction, all unknown vertex are set as discovered here and the time when they are discovered is added to their timestamps
    time is time + 1
    1st time_stamp of s is time
    state of s is "discovered"
    for each v in links of s
      if state of v is "unknown"
        DFS_From(v) //Each vertex discovered causes the beginning of a new analysis
    state of s is "known"
    time is time + 1
    2nd time_stamp of s is time
```
El tiempo de ejecución de éste algoritmo es de $O(|V|+|E|)$, ya que cada vertice será revisado solo una vez, revisando cada uno de sus vertices adyacentes, es decir, revisando cada arista. Abajo se muestra la implementación en lenguaje Python de la solución propuesta del algoritmo, seguido de instrucciones para su aplicación en graph2, grafo generado previamente.

###Depth First Search
"""

def DFS(G):
  G.time = 0
  for u in G.adj_list:
    u.state = "unknown"
    u.time_stamps = [0,0]
  def DFS_From(s): #Cada nodo hayado llama a esta función donde se actualiza el tiempo y se dan valores a sus marcas
    G.time = G.time + 1
    s.time_stamps[0] = G.time
    s.state = "discovered"
    for v in s.links:
      if v[0].state == "unknown":
        print("Node ",v[0].name," descubierto a partir de ",s.name)
        DFS_From(v[0]) #Cada nodo hayado provoca unanueva búsqueda que comienza a partir de él mismo
    s.state = "known"
    G.time = G.time + 1
    s.time_stamps[1] = G.time
  for u in G.adj_list: #Aqui comienza la búsqueda
    if u.state == "unknown":
      print("Node ",u.name," descubierto")
      DFS_From(u) 
  print("\n\n")
  for v in G.adj_list: #Se imprimen las marcas dadas a cada nodo del grafo que llamo a la función
    print(v.name," timestamps: ",v.time_stamps)

DFS(graph2)

"""###**Arbol recubridor mínimo - Algoritmo de Prim**
####Planteamiento del problema
El objetivo o la problemática con respecto este algoritmo es lograr generar un árbol a partir de un grafo dado. Éste árbol debe contener a todos los vertices del grafo original, ofreciendo el camino más corto posible a cada uno de ellos a partir de un nodo elegido como raíz.\\
Tal objetivo debe ser alcanzado a través del enfoque utilizado en el algoritmo de Prim, basado en explorar vertice por vertice, actualizando el camino más ligero para cada vertice.
####Solución propuesta
La solución propuesta para el algoritmo es una función llamada *MST_Prim*, que aplique el enfoque propuesto por Prim para generar un árbol recubridor mínimo con la estructura *Graph* y la estructura *Node*. 
####Definición del problema
Para poder llevar a la realidad la solución propuesta, es necesario plantear un algorimo que aproveche las estructuras *Graph* y *Node* para generar un árbol recubridor mínimo. El algorimo crea la lista *leafs* con el nombre de todos los vertices del grafo que recibe como argumento de entrada. Se crea la lista *branches*, la cual será una lista de listas, cada sublista tendrá 3 elementos, el segundo elemento de cada sublista se inicializa con el nombre de cada nodo en el grafo, el primer elemento tendrá el nodo que forma parte del árbol y apunta al nodo denotado en el segundo elemento, para que éste también forme parte del árbol, el tercer elemento marca el peso o distancia entre nodo y nodo.\\
Los valores en el  primer y tercer elemento de cada sublista de *branches* se actualizarán, cada nodo será analizado, siempre que se encuentre un nodo que ofrezca una mejor ruta, esa lista será actualizada. El único elemento de *branches* al que ningún nodo apuntará será el primero en ser analizado, éste se considerará la raíz del árbol y depende del orden en el que los elementos salgan de la cola utilizada para reconocer a los nodos explorados de los no explorados.\\
Una vez analizados todos los vertices, se eliminará de *branches* la sublista de la raíz. Los demás elementos de la lista serán aristas de un grafi dirigido que conecta todos los nodos del grafo original, un árbol recbridor mínimo. Los elemenos de *branches* serán duplicados con las coordenadas invertidas, esto permitirá utilizar *leafs* y *branches* como argumentos de entrada para crear un grafo no dirigido que será el árbol recubridor mínimo del grafo original. A continuación se muestra el pseudocódigo del algoritmo diseñado.
```
MST_Prim(G)
  queue is []
  leafs is []
  branches is []
  for each u in adj_list of G //Initializes all attributes and variables needed
    add name of u to leafs
    add [NULL, name of u,-1] to branches
    push u into queue
  origin is 1st node in queue
  while queue is not empty //Analyzes every node of the original graph
    pop u from queue
    for each v in adjacent to u //Checks for updates to every vertex adjacent to the one that is currently being analyzed
      temp is get_weight(name of v)
      if v in queue and temp is -1 or weight in v < temp // If a better path is found or a vertex that was not checked yet, an update is made
        for each l in branches
          if 2nd name in l is name of v
            1st name in l is name of u
            weight in l is weight in v
  remove [NULL, name of origin, -1] from branches // Extra edge is removed
  temp is []
  for each b in branches //Edges are duplicated with coordinates backwards to ensure a nondirected tree
    add [2nd name in b, 1st name in b, weight of b] to temp
  branches is branches union temp
  new Graph(leafs,branches) A //new minimum spanning tree is created 
  create adj_list of A
  for each r in adj_list of A //Root for the tree is set
    if name of r is name of origin
      root of A is r
  get_weight(leaf) //Subfunction to get the current weight of a path
    for each l in branches
      if leaf is 2nd name in l
        weight is weight in l
    return weight
  return A
```
El tiempo de ejecución de éste algoritmo es de $O(|V|^4)$, pues el algoritmo implementa 3 ciclos anidados, el primero recorre queue, que contiene a todos los vertices, el siguiente recorre todas las aristas, que en el peor de los casos serán igual a $|V|^2$, el tercero recorre *branches*, que tiene un tamaño de $|V|$. La implementación del algoritmo diseñado se muestra a continuación.

###Minimum Spanning Tree - Prim Algorithm
"""

def MST_Prim(G):
  def get_weight(leaf): #Subfunción para obtener el peso actual de cierta arista 
    for l in branches:
      if leaf == l[1]:
        weight = l[2]
    return weight
  queue = []
  leafs = []
  branches = []
  for u in G.adj_list: #Se crea la lista de verticespara elnuevo árbol y una lista para guardar qué nodo apunta a qué nodo en el árbol
    leafs.append(u.name)
    branches.append([None,u.name,-1])
    queue.append(u)
  origin = queue[-1]
  while queue: #Se analizan los nodos adyacentes de cada nodo del grafo original
    u = queue.pop()
    print(u.name," out")
    for v in u.links:
      temp = get_weight(v[0].name)
      if (v[0] in queue) and ((temp==-1) or (v[1] < temp)): #Si la distancia o peso es menor, o el nodo no tenía nada apuntandole, se actualizan las aristas del árbol
        for l in branches:
          if l[1] == v[0].name:
            l[0] = u.name
            l[2] = v[1]
            print("Now ",l[0]," points -> ",v[0].name," weigth: ",l[2])
  branches.remove([None,origin.name,-1]) #Se retira la árista extra,perteneciente a la raíz
  temp = []
  for b in branches: #Se duplican las áristas creadas durante el análisis, pero con las coordenadas al revés para generar un árbol no dirigido
    temp.append([b[1],b[0],b[2]])
  branches = branches + temp
  A = Graph(leafs,branches)
  A.create_AdjList()
  for r in A.adj_list:
    if r.name == origin.name:
      A.root = r
  return A

pmst_of_graph = MST_Prim(graph3)
print("\nPrim Minimum Spanning Tree root: ",pmst_of_graph.root.name,"\n")
pmst_of_graph.print_AdjList()

"""\\

\\

\\

\\

###**Arbol recubridor mínimo - Algoritmo de Kruskal**
####Planteamiento del problema
El objetivo o la problemática con respecto este algoritmo es, al igual que en la sección anterior, lograr generar un árbol recubridor mínimo a partir de un grafo dado. Éste árbol debe contener a todos los vertices del grafo original, ofreciendo el camino más corto posible a cada uno de ellos a partir de un nodo elegido como raíz.\\
Tal objetivo debe ser alcanzado a través del enfoque utilizado en el algoritmo de Kruskal, basado en revisar arista por arista de manera ordenada.
####Solución propuesta
La solución propuesta para el algoritmo es una función llamada *MST_Kruskal*, que aplique el enfoque propuesto por Kruskal para generar un árbol recubridor mínimo con la estructura *Graph* y la estructura *Node*. 
####Definición del problema
Para poder llevar a la realidad la solución propuesta, es necesario plantear un algorimo que aproveche las estructuras *Graph* y *Node* para generar un árbol recubridor mínimo. El algoritmo diseñado implementa el concepto de Kruskal creando una lista de listas *forest*, cada sublista contiene un solo elemento, un vertice del grafo original, esta lista se considera un conjunto de arboles formados por un solo nodo. Se analiza cada arista, de manera ordenada de acuerdo al peso o distancia entre los vertices que la conforman. Con ayuda de la subfunción *get_Tree* se revisa si los vertices que conforman a la arista analizada no pertenecen al mismo árbol, es decir, están en sublistas distintas; de ser así estás listas serán concatenadas y añadidas como un nuevo árbol a *forest*, continuando así hasta que exista un solo elemento dentro de la lista *forest*, siendo ésta la lista de vertices que servirá como argumento de entrada para crear el árbol recubridor mínimo.\\
Al mismo tiempo que se crea la lista de vertices, cada que dos árboles se unen, se añade una sublista a la lista *branches*, que guarda los dos nodos que provocan la unión de los árboles, y la distancia o peso que hay entre ellos, al finalizar el análisis, *branches* contendrá a todas las aristas que componen al arbol recubridor mínimo. \\
Al terminar el análisis un árbol es creado con el único elemento de *forest* y la lista *branches* como argumentos de entrada para la clas Graph. Para terminar, como ningún vertice es seleccionado de manera especial para ser la raíz, se elige como raíz del árbol recubridor mínimo a aquel que tiene más aristas o adyacencias. Todo lo descrito anteriormente se muestra a continuación en forma de pseudocódigo.
```
MST_Kruskal(G)
  branches is []
  forest is []
  for each v in G
    add name of v to forest
  sort edges in E of G 
  for each e in E of G  //Checks edges of the original graph sorted in the previos line
    if get_Tree(1st name in e) is not same get_Tree(2nd name in e) //If vertex belong to different trees they merge
      tree1 is get_Tree(1st name in e)
      tree2 is get_Tree(2nd name in e)
      new_tree is tree1 union tree2
      remove tree1 from forest
      remove tree2 from forest
      add new_tree to forest
      add [1st name in e, 2nd name in e, weight of e] to branches
      add [2nd name in e, 1st name in e, weight of e] to branches
  new Graph(only tree of forest,branches) A //A new Tree is created once analysis is finished
  create adj_list of A //Adjacency List of the new minimum spanning tree is created
  temp is length of links in 1st node in adj_list of A //Root is set
  origin is 1st node in adj_list of A
  for each r in adj_list of A 
    if length of links in r > temp
      origin is r
      temp is length of links in r
  root of A is origin
  get_Tree(k) //Subfunction o get the tree to which node k belongs
    for each t in forest
      for each l in t
        if l is k
          tree is t
    return tree
  return A
```

\\

\\

El tiempo de ejecución de el algoritmo propuesto es de $O(|V|^3$, debido a que el algoritmo implementa un solo ciclo que recorre todos los vertices del grafo original, que en el peor de los casos, serán $|V|^2$ vertices, dentro de éste ciclo se implementa la subfunción *get_Tree*, la cual siempre realiza en promedio un total de $|V|$ comparaciones, pues a pesar tener dos ciclos anidados, la cantidad de comparaciones máxima de ambos será de V, pero cuando la cantidad de comparaciones del primer ciclo sea $|V|$, las comparaciones del segundo ciclo serán solo 1, cuándo la cantidad de comparaciones del segundo ciclo sea $|V|$, solo será necesario realizar 1 comparación en el primero. A continuación se presenta la implementación en Python del algoritmo diseñado.

###Minimum Spanning Tree - Kruskal Algorithm
"""

def MST_Kruskal(G):
  def get_Tree(k): #Subfunción para ver a qué árbol pertenece k
    for i in forest:
      for j in i:
        if j == k:
          tree = i
    return tree
  branches = []
  forest = []
  for v in G.adj_list: #Por cada nodo del grafo original, una sublista es creada para representar un arbol del bosque
    forest.append([v.name])
  G.E.sort(key=lambda x: x[2]) #Se ordena la lista de aristas en base a la distancia o peso de cada una
  for e in G.E:  #Cada arista es revisada para ver si  los vertices que conectan ya partenecen al mismo árbol o no
    if get_Tree(e[0]) is not get_Tree(e[1]): #Si los vertices son de árboles distintos, se unen en uno nuevo
      tree1 = get_Tree(e[0])
      tree2 = get_Tree(e[1])
      new_tree = tree1 + tree2
      print(tree1," and ",tree2," merged into ",new_tree)
      forest.remove(tree1)
      forest.remove(tree2)
      forest.append(new_tree)
      branches.append([e[0],e[1],e[2]])
      branches.append([e[1],e[0],e[2]])
  A = Graph(forest[0],branches) #El árbol recubridor mínimo es generado
  A.create_AdjList()
  temp = len(A.adj_list[0].links) #Se elige raíz del árbol al nodo con más aristas
  origin = A.adj_list[0] 
  for r in A.adj_list:
    if len(r.links) > temp:
      origin = r
  A.root = origin
  return A

kmst_of_graph = MST_Kruskal(graph3)
print("Kruskal Minimum Spanning Tree root: ",kmst_of_graph.root.name,"\n")
kmst_of_graph.print_AdjList()

"""###**Conclusión**
Los algoritmos implementados son buenas demostraciones del análisis de grafos. A pesar de que un poco más de trabajo podría haber permitido un diseño más eficiente en cuanto al tiempo de ejecución de los algoritmos, esto queda como posibles mejoras ah implementar, o por otro lado, el costo en memoria podría ser disminuído, sin embargo el diseño propuesto hace el código más entendible. Los programas escritos para este proyecto pueden ser de gran útilidad para futuros trabajos, los grafos son estructuras de datos importantes en la programación, y los algoritmos para su análisis no son menos importantes.
"""